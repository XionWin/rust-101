# Programming a Guessing Game

Let's jump into Rust by working through a üìùhead-on(Involving active participation) project together! This chapter introduces you to a few common Rust concepts by showing you how to use them in a real program. You'll learn about `let, match`, methods, associated functions, external crates, and more! In the following chapters, we'll explore these ideas in more details. In this chapter, you'll just practice the fundamentals.

We'll implement a classic beginner programming problem: a guessing game. Here's how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess the guess is too low or to high.  If the guess is correct, the game will print a congratulatory message and exit.

## Setting Up a New Project

To set up a new project, go to the `projects` directory that you created in Chapter 1 and make a new project using `Cargo`, like so:  
```
$ cargo new  guessing_game
$ cd guessing_game
```
This first command, `cargo new`, takes the name of the project(guessing_game) as the first argument, The second command changes to the new project's directory.

Loo at the generated `Cargo.toml` file:

Filename: `Cargo.toml`
```
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```
As you saw in Chapter 1, `cargo new` generates a "Hello, world!" program for you.Check out the `src/main.rs` file:

Filename: `src/main.rs`
```
fn main() {
    println!("Hello, world!");
}
```
Now let's compile this "Hello, world!" program and run it in the same step using the `cargo run` command: 
```
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
```
The `run` command comes in handy when you need rapidly iterate on a project, as we'll do in this game,  quickly testing each iteration before moving on the next one.

Reopen the `src/main.rs` file. You'll be all the code in this file.

## Processing a Guess

The first part of the guessing game program will ask for use input,process that input, and check that the input is in the expected form. To start, we'll allow the player to input a guess. Enter the code in Listing 2-1 into `src/main.rs`.

Filename: `src/main.rs`
```
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```
`Listing 201: Code that gets a guess from the user and prints it`

This code contains a lot of information, so let's go over it line by line. To obtain user input and then print the result as output, we need to bring the `io` input/output library into scope. The `io` library comes from the standard library, known as `std`:
```
use std::io;
```
By default, Rust has a set of items defined in the standard library that it brings into the scope of every program. This set is called the `prelude`, and you can see everything in it `in the standard library documentation`.

If a type you want to use isn't in the prelude, you have to bring that type scope explicitly with a `use` statement. Using the `std::io` library provides you with a number of useful features, including the ability to accept user input.

As you saw in Chapter 1, the `main` function is the entry point into the program:
```
fn main() {}
```
The `fn` syntax declares a new function; this parentheses, (), indicate there are no parameters; and the curly bracket, {, starts the body of the function.

As you also learned in Chapter 1, `println!` is a macro that prints a string to the screen:
```
    println!("Guess the number!");
    println!("Please input your guess.");
```
This code is printing a prompt starting what the game is and requesting input from the user.

## Storing Values with Variables

Next, we'll create a `varibale` to store the user input, like this:
```
    let mut guess = Sting::new();
```
Now the program is getting interesting! There's a lot going on in this little line. We use the `let` statement to create the variable. Here's another example:
```
    let apples = 5;
```
This line creates a new variable named `apples` and binds it to the value 5. In Rust, variables are immutable by default, meaning once we give the variable a value, the value won't change. We'll be discussing this concept in detail in the `Varibales and Mutablility` section in Chapter 3. To make a variable mutable, we ad `mut` before the variable name:
```
let apples = 5; // immutable
let mut bananas = 5; // mutable
```
```
Note: The `//` syntax starts a comment that continues until the end of the line. Rsut ignores everything in comments. We'll discuss comments in more detail in Chapter 3.
```
Returning to the guessing game program, you now know that `let mut guess` will introduce a mutable variable named `guess`. The equal sign (=) tells Rust we want to bind something to the variable now. On the right of the equal sign is the value that `guess` is bound toÔºå which is the result of calling `String::new`, a function that returns a new instance of a `String`. `String` is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text.

The `::` syntax in the `::new` line indicates that `new` is an associated function of the `String` type. An associated function is a function that's implemented on a type, in this case `String`. This `new` function creates a new, empty string. You'll find a `new` function on many types because it's a common name for a function that makes a new value of some kind.

In full, the `let mut guess = String::new();` line has created a mutable variable that is currently bound to a new, empty instance of a "String". Whew!

## Receiving User input

Recall that we included that input/output functionally from the standard library with `use std::io;` on the first line of the program. Now we'll call the `stdin` function form the `io` module, which will allow us to handle `user` input:
```
    io::stdin()
        .read_line(&mut guess)
```
If we hadn't imported the `io` library with `use std::io;` at the beginning of the program, we could still use the function by writing this function call as `std::io::stdin`. The `stdin` function returns an instance of `std::io::stdin`, which is a type that represents a handle to the standard input for your terminal.

Next, the line `.read_line(&mut guess)` calls the `read_line` method on the standard input handle to get input from the user. We're also passing `&mut guess` as the argument to `read_line` to tell it what string to store the user input in. The full job of `read_line` is to take whatever the user types into standard input and append that into a string (without overwriting its contents), so we therefore pas that string as an argument. The string argument needs to be mutable so that method can change the string's content.

The `&` indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust's major advantages is how safe and easy it is to use references. You don't need to know a lot of those details to finish this program. For now, all you need to know is that, like variables, references are immutable by default. üìùHence (Âõ†Ê≠§), you need to write `&mut guess` rather than `&guess` to make it mutable. (Chapter 4 will explain references more thoroughly).


